from fastapi import APIRouter, HTTPException, Path as APIPath, Query
from fastapi.responses import FileResponse
from pathlib import Path
import shutil
import logging

# Import core components
from gittxt.core.config import ConfigManager
from gittxt.core.constants import TEXT_DIR, JSON_DIR, MD_DIR, ZIP_DIR
from gittxt.api.schemas.download import OutputFormat  # Keep schema for validation

router = APIRouter()
logger = logging.getLogger(__name__)

# Map API format enum to core directory constants and expected media types
FORMAT_MAP = {
    OutputFormat.txt: (TEXT_DIR, "text/plain"),
    OutputFormat.md: (MD_DIR, "text/markdown"),
    OutputFormat.json: (JSON_DIR, "application/json"),
    OutputFormat.zip: (ZIP_DIR, "application/zip"),
}

@router.get("/download/{scan_id}/{repo_name}/{format}", tags=["Download"])
async def download_file(
    scan_id: str = APIPath(..., description="Unique identifier for the scan session"),
    repo_name: str = APIPath(..., description="Name of the repository scanned"),
    format: OutputFormat = APIPath(..., description="Desired output format: txt, md, json, or zip")
):
    """
    Download a specific output file generated by a Gittxt scan.
    Requires scan_id and the original repository name.
    """
    if format not in FORMAT_MAP:
        raise HTTPException(status_code=400, detail=f"Invalid format requested: {format}")

    try:
        config = ConfigManager.load_config()
        output_dir_base = Path(config.get("output_dir", "./gittxt_output"))
        scan_output_dir = output_dir_base / scan_id

        if not scan_output_dir.exists() or not scan_output_dir.is_dir():
            raise HTTPException(status_code=404, detail=f"Scan ID '{scan_id}' output directory not found.")

        format_dir_name, media_type = FORMAT_MAP[format]
        format_specific_dir = scan_output_dir / format_dir_name

        # Construct expected filename based on core OutputBuilder logic (repo_name + extension)
        if format == OutputFormat.zip:
            expected_filename = f"{repo_name}.zip"
        elif format == OutputFormat.txt:
            expected_filename = f"{repo_name}.txt"
        elif format == OutputFormat.md:
            expected_filename = f"{repo_name}.md"
        elif format == OutputFormat.json:
            expected_filename = f"{repo_name}.json"
        else:
            raise HTTPException(status_code=500, detail="Internal error: Unhandled format.")

        file_path = format_specific_dir / expected_filename

        if not file_path.exists() or not file_path.is_file():
            logger.warning(f"Requested file not found: {file_path}")
            if not format_specific_dir.exists():
                detail_msg = f"Output directory for format '{format.value}' not found for scan '{scan_id}'."
            else:
                detail_msg = f"Requested output file '{expected_filename}' not found in '{format_specific_dir.relative_to(output_dir_base)}' for scan '{scan_id}'. Available formats might differ."
            raise HTTPException(status_code=404, detail=detail_msg)

        logger.info(f"Serving file: {file_path} for scan {scan_id}")
        return FileResponse(
            path=str(file_path),
            filename=expected_filename,
            media_type=media_type,
        )

    except HTTPException as http_exc:
        raise http_exc
    except Exception as e:
        logger.error(f"Error during download for scan '{scan_id}', repo '{repo_name}', format '{format}': {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Internal server error during download: {str(e)}")
